# --- Duration Calculation (Safe HH:mm:ss) ---
try {
    $createdDate = $latestRun.createdDate
    $finishedDate = $latestRun.finishedDate

    if (-not $createdDate -or -not $finishedDate) {
        throw "Missing createdDate or finishedDate."
    }

    $startTime = [datetime]::Parse($createdDate.ToString())
    $endTime   = [datetime]::Parse($finishedDate.ToString())

    $duration = New-TimeSpan -Start $startTime -End $endTime

    # Format as HH:mm:ss
    $durationFormatted = '{0:00}:{1:00}:{2:00}' -f $duration.Hours, $duration.Minutes, $duration.Seconds
}
catch {
    Write-Error "❌ General error occurred while processing pipeline telemetry: Failed to calculate duration: $_"
    $durationFormatted = $null
}

Write-Host "createdDate raw: $($latestRun.createdDate)"
Write-Host "finishedDate raw: $($latestRun.finishedDate)"


try {
    $createdDate = $latestRun.createdDate
    $finishedDate = $latestRun.finishedDate

    # Handle case where it's an array
    if ($createdDate -is [System.Array]) {
        $createdDate = $createdDate[0]
    }
    if ($finishedDate -is [System.Array]) {
        $finishedDate = $finishedDate[0]
    }

    $startTime = [datetime]::Parse($createdDate.ToString())
    $endTime   = [datetime]::Parse($finishedDate.ToString())

    $duration = New-TimeSpan -Start $startTime -End $endTime
    $durationFormatted = '{0:00}:{1:00}:{2:00}' -f $duration.Hours, $duration.Minutes, $duration.Seconds
}
catch {
    Write-Error "❌ General error occurred while processing pipeline telemetry: Failed to calculate duration: $_"
    $durationFormatted = $null
}


data('azure.pipeline.execution.details')
  .filter(key='pipelineName', value='YourPipelineName')  // Optional
  .group_by(['runId', 'status', 'result'])               // Add dimensions you want
  .publish(label='Pipeline Duration by Run')

A = data("azure.pipeline.run.count", rollup="count").sum(by=["pipeline_name"])
B = A.sum(by=["pipeline_name"]).publish(label="Pipeline Runs")


================
foreach ($run in $pipelineRuns) {
    try {
        $createdDate = $run.createdDate
        $finishedDate = $run.finishedDate

        # Convert to datetime
        $startTime = [datetime]::Parse($createdDate.ToString())
        $endTime = [datetime]::Parse($finishedDate.ToString())

        # Convert to epoch (in milliseconds)
        $timestamp = [int64](($startTime.ToUniversalTime() - [datetime]'1970-01-01').TotalSeconds * 1000)

        # Calculate duration in seconds
        $duration = [int]((Get-Date $endTime).ToUniversalTime() - (Get-Date $startTime).ToUniversalTime()).TotalSeconds

        # Build dimensions (add whatever you need)
        $dimensions = @{
            "pipelineName" = $run.name
            "result"       = $run.result
            "status"       = $run.status
        }

        # Send as gauge
        $gauge = @{
            "metric"    = "pipeline.execution.duration"
            "value"     = $duration
            "timestamp" = $timestamp      # ✅ this makes sure time in Splunk is correct
            "dimensions" = $dimensions
        }

        # Convert to JSON and send (example using Invoke-RestMethod)
        $jsonBody = $gauge | ConvertTo-Json -Depth 10
        Invoke-RestMethod -Method Post -Uri $splunkUrl -Body $jsonBody -ContentType "application/json"

    } catch {
        Write-Error "Failed for pipeline run $($run.id): $_"
    }
}


